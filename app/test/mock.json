{
  "status": "success",
  "task_id": 1423,
  "vul_array": [
    3999
  ],
  "file_url": "",
  "file": "/*\n  +----------------------------------------------------------------------+\n  | TAR archive support for Phar                                         |\n  +----------------------------------------------------------------------+\n  | Copyright (c) 2005-2018 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt.                                 |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Authors: Dmitry Stogov <dmitry@zend.com>                             |\n  |          Gregory Beaver <cellog@php.net>                             |\n  +----------------------------------------------------------------------+\n*/\n\n#include \"phar_internal.h\"\n\nstatic uint32_t phar_tar_number(char *buf, int len) /* {{{ */\n{\n\tuint32_t num = 0;\n\tint i = 0;\n\n\twhile (i < len && buf[i] == ' ') {\n\t\t++i;\n\t}\n\n\twhile (i < len && buf[i] >= '0' && buf[i] <= '7') {\n\t\tnum = num * 8 + (buf[i] - '0');\n\t\t++i;\n\t}\n\n\treturn num;\n}\n/* }}} */\n\n/* adapted from format_octal() in libarchive\n *\n * Copyright (c) 2003-2009 Tim Kientzle\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nstatic int phar_tar_octal(char *buf, uint32_t val, int len) /* {{{ */\n{\n\tchar *p = buf;\n\tint s = len;\n\n\tp += len;\t\t/* Start at the end and work backwards. */\n\twhile (s-- > 0) {\n\t\t*--p = (char)('0' + (val & 7));\n\t\tval >>= 3;\n\t}\n\n\tif (val == 0)\n\t\treturn SUCCESS;\n\n\t/* If it overflowed, fill field with max value. */\n\twhile (len-- > 0)\n\t\t*p++ = '7';\n\n\treturn FAILURE;\n}\n/* }}} */\n\nstatic uint32_t phar_tar_checksum(char *buf, int len) /* {{{ */\n{\n\tuint32_t sum = 0;\n\tchar *end = buf + len;\n\n\twhile (buf != end) {\n\t\tsum += (unsigned char)*buf;\n\t\t++buf;\n\t}\n\treturn sum;\n}\n/* }}} */\n\nint phar_is_tar(char *buf, char *fname) /* {{{ */\n{\n\ttar_header *header = (tar_header *) buf;\n\tuint32_t checksum = phar_tar_number(header->checksum, sizeof(header->checksum));\n\tuint32_t ret;\n\tchar save[sizeof(header->checksum)], *bname;\n\n\t/* assume that the first filename in a tar won't begin with <?php */\n\tif (!strncmp(buf, \"<?php\", sizeof(\"<?php\")-1)) {\n\t\treturn 0;\n\t}\n\n\tmemcpy(save, header->checksum, sizeof(header->checksum));\n\tmemset(header->checksum, ' ', sizeof(header->checksum));\n\tret = (checksum == phar_tar_checksum(buf, 512));\n\tmemcpy(header->checksum, save, sizeof(header->checksum));\n\tif ((bname = strrchr(fname, PHP_DIR_SEPARATOR))) {\n\t\tfname = bname;\n\t}\n\tif (!ret && (bname = strstr(fname, \".tar\")) && (bname[4] == '\\0' || bname[4] == '.')) {\n\t\t/* probably a corrupted tar - so we will pretend it is one */\n\t\treturn 1;\n\t}\n\treturn ret;\n}\n/* }}} */\n\nint phar_open_or_create_tar(char *fname, int fname_len, char *alias, int alias_len, int is_data, int options, phar_archive_data** pphar, char **error) /* {{{ */\n{\n\tphar_archive_data *phar;\n\tint ret = phar_create_or_parse_filename(fname, fname_len, alias, alias_len, is_data, options, &phar, error);\n\n\tif (FAILURE == ret) {\n\t\treturn FAILURE;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = phar;\n\t}\n\n\tphar->is_data = is_data;\n\n\tif (phar->is_tar) {\n\t\treturn ret;\n\t}\n\n\tif (phar->is_brandnew) {\n\t\tphar->is_tar = 1;\n\t\tphar->is_zip = 0;\n\t\tphar->internal_file_start = 0;\n\t\treturn SUCCESS;\n\t}\n\n\t/* we've reached here - the phar exists and is a regular phar */\n\tif (error) {\n\t\tspprintf(error, 4096, \"phar tar error: \\\"%s\\\" already exists as a regular phar and must be deleted from disk prior to creating as a tar-based phar\", fname);\n\t}\n\treturn FAILURE;\n}\n/* }}} */\n\nstatic int phar_tar_process_metadata(phar_entry_info *entry, php_stream *fp) /* {{{ */\n{\n\tchar *metadata;\n\tsize_t save = php_stream_tell(fp), read;\n\tphar_entry_info *mentry;\n\n\tmetadata = (char *) safe_emalloc(1, entry->uncompressed_filesize, 1);\n\n\tread = php_stream_read(fp, metadata, entry->uncompressed_filesize);\n\tif (read != entry->uncompressed_filesize) {\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\n\tif (phar_parse_metadata(&metadata, &entry->metadata, entry->uncompressed_filesize) == FAILURE) {\n\t\t/* if not valid serialized data, it is a regular string */\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->filename_len == sizeof(\".phar/.metadata.bin\")-1 && !memcmp(entry->filename, \".phar/.metadata.bin\", sizeof(\".phar/.metadata.bin\")-1)) {\n\t\tentry->phar->metadata = entry->metadata;\n\t\tZVAL_UNDEF(&entry->metadata);\n\t} else if (entry->filename_len >= sizeof(\".phar/.metadata/\") + sizeof(\"/.metadata.bin\") - 1 && NULL != (mentry = zend_hash_str_find_ptr(&(entry->phar->manifest), entry->filename + sizeof(\".phar/.metadata/\") - 1, entry->filename_len - (sizeof(\"/.metadata.bin\") - 1 + sizeof(\".phar/.metadata/\") - 1)))) {\n\t\t/* transfer this metadata to the entry it refers */\n\t\tmentry->metadata = entry->metadata;\n\t\tZVAL_UNDEF(&entry->metadata);\n\t}\n\n\tefree(metadata);\n\tphp_stream_seek(fp, save, SEEK_SET);\n\treturn SUCCESS;\n}\n/* }}} */\n\n#if !HAVE_STRNLEN\nstatic size_t strnlen(const char *s, size_t maxlen) {\n        char *r = (char *)memchr(s, '\\0', maxlen);\n        return r ? r-s : maxlen;\n}\n#endif\n\nint phar_parse_tarfile(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, int is_data, uint32_t compression, char **error) /* {{{ */\n{\n\tchar buf[512], *actual_alias = NULL, *p;\n\tphar_entry_info entry = {0};\n\tsize_t pos = 0, read, totalsize;\n\ttar_header *hdr;\n\tuint32_t sum1, sum2, size, old;\n\tphar_archive_data *myphar, *actual;\n\tint last_was_longlink = 0;\n\tint linkname_len;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tphp_stream_seek(fp, 0, SEEK_END);\n\ttotalsize = php_stream_tell(fp);\n\tphp_stream_seek(fp, 0, SEEK_SET);\n\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\tif (read != sizeof(buf)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is not a tar file or is truncated\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\thdr = (tar_header*)buf;\n\told = (memcmp(hdr->magic, \"ustar\", sizeof(\"ustar\")-1) != 0);\n\n\tmyphar = (phar_archive_data *) pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmyphar->is_persistent = PHAR_G(persist);\n\t/* estimate number of entries, can't be certain with tar files */\n\tzend_hash_init(&myphar->manifest, 2 + (totalsize >> 12),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->virtual_dirs, 4 + (totalsize >> 11),\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tmyphar->is_tar = 1;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmyphar->flags = compression;\n\n\tentry.is_tar = 1;\n\tentry.is_crc_checked = 1;\n\tentry.phar = myphar;\n\tpos += sizeof(buf);\n\n\tdo {\n\t\tphar_entry_info *newentry;\n\n\t\tpos = php_stream_tell(fp);\n\t\thdr = (tar_header*) buf;\n\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(hdr->checksum, ' ', sizeof(hdr->checksum));\n\t\tsum2 = phar_tar_checksum(buf, old?sizeof(old_tar_header):sizeof(tar_header));\n\n\t\tsize = entry.uncompressed_filesize = entry.compressed_filesize =\n\t\t\tphar_tar_number(hdr->size, sizeof(hdr->size));\n\n\t\t/* skip global/file headers (pax) */\n\t\tif (!old && (hdr->typeflag == TAR_GLOBAL_HDR || hdr->typeflag == TAR_FILE_HDR)) {\n\t\t\tsize = (size+511)&~511;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (((!old && hdr->prefix[0] == 0) || old) && strnlen(hdr->name, 100) == sizeof(\".phar/signature.bin\")-1 && !strncmp(hdr->name, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {\n\t\t\tzend_off_t curloc;\n\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has signature that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\nbail:\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcurloc = php_stream_tell(fp);\n\t\t\tread = php_stream_read(fp, buf, size);\n\t\t\tif (read != size || read <= 8) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be read\", fname);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n#ifdef WORDS_BIGENDIAN\n# define PHAR_GET_32(buffer) \\\n\t(((((unsigned char*)(buffer))[3]) << 24) \\\n\t\t| ((((unsigned char*)(buffer))[2]) << 16) \\\n\t\t| ((((unsigned char*)(buffer))[1]) <<  8) \\\n\t\t| (((unsigned char*)(buffer))[0]))\n#else\n# define PHAR_GET_32(buffer) (uint32_t) *(buffer)\n#endif\n\t\t\tmyphar->sig_flags = PHAR_GET_32(buf);\n\t\t\tif (FAILURE == phar_verify_signature(fp, php_stream_tell(fp) - size - 512, myphar->sig_flags, buf + 8, size - 8, fname, &myphar->signature, &myphar->sig_len, error)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tchar *save = *error;\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be verified: %s\", fname, save);\n\t\t\t\t\tefree(save);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tphp_stream_seek(fp, curloc + 512, SEEK_SET);\n\t\t\t/* signature checked out, let's ensure this is the last file in the phar */\n\t\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\t\tphp_stream_seek(fp, 512, SEEK_CUR);\n\t\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\thdr = (tar_header*) buf;\n\t\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\n\t\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" has entries after signature, invalid phar\", fname);\n\t\t\t}\n\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!last_was_longlink && hdr->typeflag == 'L') {\n\t\t\tlast_was_longlink = 1;\n\t\t\t/* support the ././@LongLink system for storing long filenames */\n\t\t\tentry.filename_len = entry.uncompressed_filesize;\n\n\t\t\t/* Check for overflow - bug 61065 */\n\t\t\tif (entry.filename_len == UINT_MAX || entry.filename_len == 0) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (invalid entry size)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);\n\n\t\t\tread = php_stream_read(fp, entry.filename, entry.filename_len);\n\t\t\tif (read != entry.filename_len) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename[entry.filename_len] = '\\0';\n\n\t\t\t/* skip blank stuff */\n\t\t\tsize = ((size+511)&~511) - size;\n\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (!last_was_longlink && !old && hdr->prefix[0] != 0) {\n\t\t\tchar name[256];\n\t\t\tint i, j;\n\n\t\t\tfor (i = 0; i < 155; i++) {\n\t\t\t\tname[i] = hdr->prefix[i];\n\t\t\t\tif (name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tname[i++] = '/';\n\t\t\tfor (j = 0; j < 100; j++) {\n\t\t\t\tname[i+j] = hdr->name[j];\n\t\t\t\tif (name[i+j] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry.filename_len = i+j;\n\n\t\t\tif (name[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t\tentry.filename = pestrndup(name, entry.filename_len, myphar->is_persistent);\n\t\t} else if (!last_was_longlink) {\n\t\t\tint i;\n\n\t\t\t/* calculate strlen, which can be no longer than 100 */\n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tif (hdr->name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.filename_len = i;\n\t\t\tentry.filename = pestrndup(hdr->name, i, myphar->is_persistent);\n\n\t\t\tif (i > 0 && entry.filename[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename[entry.filename_len - 1] = '\\0';\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t}\n\t\tlast_was_longlink = 0;\n\n\t\tphar_add_virtual_dirs(myphar, entry.filename, entry.filename_len);\n\n\t\tif (sum1 != sum2) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (checksum mismatch of file \\\"%s\\\")\", fname, entry.filename);\n\t\t\t}\n\t\t\tpefree(entry.filename, myphar->is_persistent);\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tentry.tar_type = ((old & (hdr->typeflag == '\\0')) ? TAR_FILE : hdr->typeflag);\n\t\tentry.offset = entry.offset_abs = pos; /* header_offset unused in tar */\n\t\tentry.fp_type = PHAR_FP;\n\t\tentry.flags = phar_tar_number(hdr->mode, sizeof(hdr->mode)) & PHAR_ENT_PERM_MASK;\n\t\tentry.timestamp = phar_tar_number(hdr->mtime, sizeof(hdr->mtime));\n\t\tentry.is_persistent = myphar->is_persistent;\n\n\t\tif (old && entry.tar_type == TAR_FILE && S_ISDIR(entry.flags)) {\n\t\t\tentry.tar_type = TAR_DIR;\n\t\t}\n\n\t\tif (entry.tar_type == TAR_DIR) {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tentry.link = NULL;\n\t\t/* link field is null-terminated unless it has 100 non-null chars.\n\t\t * Thus we can not use strlen. */\n\t\tlinkname_len = strnlen(hdr->linkname, 100);\n\t\tif (entry.tar_type == TAR_LINK) {\n\t\t\tif (!zend_hash_str_exists(&myphar->manifest, hdr->linkname, linkname_len)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file - hard link to non-existent file \\\"%.*s\\\"\", fname, linkname_len, hdr->linkname);\n\t\t\t\t}\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.link = estrndup(hdr->linkname, linkname_len);\n\t\t} else if (entry.tar_type == TAR_SYMLINK) {\n\t\t\tentry.link = estrndup(hdr->linkname, linkname_len);\n\t\t}\n\t\tphar_set_inode(&entry);\n\n\t\tnewentry = zend_hash_str_update_mem(&myphar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info));\n\t\tZEND_ASSERT(newentry != NULL);\n\n\t\tif (entry.is_persistent) {\n\t\t\t++entry.manifest_pos;\n\t\t}\n\n\t\tif (entry.filename_len >= sizeof(\".phar/.metadata\")-1 && !memcmp(entry.filename, \".phar/.metadata\", sizeof(\".phar/.metadata\")-1)) {\n\t\t\tif (FAILURE == phar_tar_process_metadata(newentry, fp)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has invalid metadata in magic file \\\"%s\\\"\", fname, entry.filename);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\t\t/* found explicit alias */\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has alias that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, size);\n\n\t\t\tif (read == size) {\n\t\t\t\tbuf[size] = '\\0';\n\t\t\t\tif (!phar_validate_alias(buf, size)) {\n\t\t\t\t\tif (size > 50) {\n\t\t\t\t\t\tbuf[50] = '.';\n\t\t\t\t\t\tbuf[51] = '.';\n\t\t\t\t\t\tbuf[52] = '.';\n\t\t\t\t\t\tbuf[53] = '\\0';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in tar-based phar \\\"%s\\\"\", buf, fname);\n\t\t\t\t\t}\n\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tactual_alias = pestrndup(buf, size, myphar->is_persistent);\n\t\t\t\tmyphar->alias = actual_alias;\n\t\t\t\tmyphar->alias_len = size;\n\t\t\t\tphp_stream_seek(fp, pos, SEEK_SET);\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to read alias from tar-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tsize = (size+511)&~511;\n\n\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\nnext:\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\tif (read != sizeof(buf)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t}\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar);\n\t\t\treturn FAILURE;\n\t\t}\n\t} while (!php_stream_eof(fp));\n\n\tif (zend_hash_str_exists(&(myphar->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tmyphar->is_data = 0;\n\t} else {\n\t\tmyphar->is_data = 1;\n\t}\n\n\t/* ensure signature set */\n\tif (!myphar->is_data && PHAR_G(require_hash) && !myphar->signature) {\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"tar-based phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tmyphar->fname = pestrndup(fname, fname_len, myphar->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(myphar->fname, fname_len);\n#endif\n\tmyphar->fname_len = fname_len;\n\tmyphar->fp = fp;\n\tp = strrchr(myphar->fname, '/');\n\n\tif (p) {\n\t\tmyphar->ext = memchr(p, '.', (myphar->fname + fname_len) - p);\n\t\tif (myphar->ext == p) {\n\t\t\tmyphar->ext = memchr(p + 1, '.', (myphar->fname + fname_len) - p - 1);\n\t\t}\n\t\tif (myphar->ext) {\n\t\t\tmyphar->ext_len = (myphar->fname + fname_len) - myphar->ext;\n\t\t}\n\t}\n\n\tphar_request_initialize();\n\n\tif (NULL == (actual = zend_hash_str_add_ptr(&(PHAR_G(phar_fname_map)), myphar->fname, fname_len, myphar))) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\" to phar registry\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar);\n\t\treturn FAILURE;\n\t}\n\n\tmyphar = actual;\n\n\tif (actual_alias) {\n\t\tphar_archive_data *fd_ptr;\n\n\t\tmyphar->is_temporary_alias = 0;\n\n\t\tif (NULL != (fd_ptr = zend_hash_str_find_ptr(&(PHAR_G(phar_alias_map)), actual_alias, myphar->alias_len))) {\n\t\t\tif (SUCCESS != phar_free_alias(fd_ptr, actual_alias, myphar->alias_len)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t}\n\t\t\t\tzend_hash_str_del(&(PHAR_G(phar_fname_map)), myphar->fname, fname_len);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_str_add_ptr(&(PHAR_G(phar_alias_map)), actual_alias, myphar->alias_len, myphar);\n\t} else {\n\t\tphar_archive_data *fd_ptr;\n\n\t\tif (alias_len) {\n\t\t\tif (NULL != (fd_ptr = zend_hash_str_find_ptr(&(PHAR_G(phar_alias_map)), alias, alias_len))) {\n\t\t\t\tif (SUCCESS != phar_free_alias(fd_ptr, alias, alias_len)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_str_del(&(PHAR_G(phar_fname_map)), myphar->fname, fname_len);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tzend_hash_str_add_ptr(&(PHAR_G(phar_alias_map)), alias, alias_len, myphar);\n\t\t\tmyphar->alias = pestrndup(alias, alias_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = alias_len;\n\t\t} else {\n\t\t\tmyphar->alias = pestrndup(myphar->fname, fname_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = fname_len;\n\t\t}\n\n\t\tmyphar->is_temporary_alias = 1;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = myphar;\n\t}\n\n\treturn SUCCESS;\n}\n/* }}} */\n\nstruct _phar_pass_tar_info {\n\tphp_stream *old;\n\tphp_stream *new;\n\tint free_fp;\n\tint free_ufp;\n\tchar **error;\n};\n\nstatic int phar_tar_writeheaders_int(phar_entry_info *entry, void *argument) /* {{{ */\n{\n\ttar_header header;\n\tsize_t pos;\n\tstruct _phar_pass_tar_info *fp = (struct _phar_pass_tar_info *)argument;\n\tchar padding[512];\n\n\tif (entry->is_mounted) {\n\t\treturn ZEND_HASH_APPLY_KEEP;\n\t}\n\n\tif (entry->is_deleted) {\n\t\tif (entry->fp_refcount <= 0) {\n\t\t\treturn ZEND_HASH_APPLY_REMOVE;\n\t\t} else {\n\t\t\t/* we can't delete this in-memory until it is closed */\n\t\t\treturn ZEND_HASH_APPLY_KEEP;\n\t\t}\n\t}\n\n\tphar_add_virtual_dirs(entry->phar, entry->filename, entry->filename_len);\n\tmemset((char *) &header, 0, sizeof(header));\n\n\tif (entry->filename_len > 100) {\n\t\tchar *boundary;\n\t\tif (entry->filename_len > 256) {\n\t\t\tif (fp->error) {\n\t\t\t\tspprintf(fp->error, 4096, \"tar-based phar \\\"%s\\\" cannot be created, filename \\\"%s\\\" is too long for tar file format\", entry->phar->fname, entry->filename);\n\t\t\t}\n\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t}\n\t\tboundary = entry->filename + entry->filename_len - 101;\n\t\twhile (*boundary && *boundary != '/') {\n\t\t\t++boundary;\n\t\t}\n\t\tif (!*boundary || ((boundary - entry->filename) > 155)) {\n\t\t\tif (fp->error) {\n\t\t\t\tspprintf(fp->error, 4096, \"tar-based phar \\\"%s\\\" cannot be created, filename \\\"%s\\\" is too long for tar file format\", entry->phar->fname, entry->filename);\n\t\t\t}\n\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t}\n\t\tmemcpy(header.prefix, entry->filename, boundary - entry->filename);\n\t\tmemcpy(header.name, boundary + 1, entry->filename_len - (boundary + 1 - entry->filename));\n\t} else {\n\t\tmemcpy(header.name, entry->filename, entry->filename_len);\n\t}\n\n\tphar_tar_octal(header.mode, entry->flags & PHAR_ENT_PERM_MASK, sizeof(header.mode)-1);\n\n\tif (FAILURE == phar_tar_octal(header.size, entry->uncompressed_filesize, sizeof(header.size)-1)) {\n\t\tif (fp->error) {\n\t\t\tspprintf(fp->error, 4096, \"tar-based phar \\\"%s\\\" cannot be created, filename \\\"%s\\\" is too large for tar file format\", entry->phar->fname, entry->filename);\n\t\t}\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\n\tif (FAILURE == phar_tar_octal(header.mtime, entry->timestamp, sizeof(header.mtime)-1)) {\n\t\tif (fp->error) {\n\t\t\tspprintf(fp->error, 4096, \"tar-based phar \\\"%s\\\" cannot be created, file modification time of file \\\"%s\\\" is too large for tar file format\", entry->phar->fname, entry->filename);\n\t\t}\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\n\t/* calc checksum */\n\theader.typeflag = entry->tar_type;\n\n\tif (entry->link) {\n\t\tstrncpy(header.linkname, entry->link, strlen(entry->link));\n\t}\n\n\tstrncpy(header.magic, \"ustar\", sizeof(\"ustar\")-1);\n\tstrncpy(header.version, \"00\", sizeof(\"00\")-1);\n\tstrncpy(header.checksum, \"        \", sizeof(\"        \")-1);\n\tentry->crc32 = phar_tar_checksum((char *)&header, sizeof(header));\n\n\tif (FAILURE == phar_tar_octal(header.checksum, entry->crc32, sizeof(header.checksum)-1)) {\n\t\tif (fp->error) {\n\t\t\tspprintf(fp->error, 4096, \"tar-based phar \\\"%s\\\" cannot be created, checksum of file \\\"%s\\\" is too large for tar file format\", entry->phar->fname, entry->filename);\n\t\t}\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\n\t/* write header */\n\tentry->header_offset = php_stream_tell(fp->new);\n\n\tif (sizeof(header) != php_stream_write(fp->new, (char *) &header, sizeof(header))) {\n\t\tif (fp->error) {\n\t\t\tspprintf(fp->error, 4096, \"tar-based phar \\\"%s\\\" cannot be created, header for  file \\\"%s\\\" could not be written\", entry->phar->fname, entry->filename);\n\t\t}\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\n\tpos = php_stream_tell(fp->new); /* save start of file within tar */\n\n\t/* write contents */\n\tif (entry->uncompressed_filesize) {\n\t\tif (FAILURE == phar_open_entry_fp(entry, fp->error, 0)) {\n\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t}\n\n\t\tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 0)) {\n\t\t\tif (fp->error) {\n\t\t\t\tspprintf(fp->error, 4096, \"tar-based phar \\\"%s\\\" cannot be created, contents of file \\\"%s\\\" could not be written, seek failed\", entry->phar->fname, entry->filename);\n\t\t\t}\n\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t}\n\n\t\tif (SUCCESS != php_stream_copy_to_stream_ex(phar_get_efp(entry, 0), fp->new, entry->uncompressed_filesize, NULL)) {\n\t\t\tif (fp->error) {\n\t\t\t\tspprintf(fp->error, 4096, \"tar-based phar \\\"%s\\\" cannot be created, contents of file \\\"%s\\\" could not be written\", entry->phar->fname, entry->filename);\n\t\t\t}\n\t\t\treturn ZEND_HASH_APPLY_STOP;\n\t\t}\n\n\t\tmemset(padding, 0, 512);\n\t\tphp_stream_write(fp->new, padding, ((entry->uncompressed_filesize +511)&~511) - entry->uncompressed_filesize);\n\t}\n\n\tif (!entry->is_modified && entry->fp_refcount) {\n\t\t/* open file pointers refer to this fp, do not free the stream */\n\t\tswitch (entry->fp_type) {\n\t\t\tcase PHAR_FP:\n\t\t\t\tfp->free_fp = 0;\n\t\t\t\tbreak;\n\t\t\tcase PHAR_UFP:\n\t\t\t\tfp->free_ufp = 0;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tentry->is_modified = 0;\n\n\tif (entry->fp_type == PHAR_MOD && entry->fp != entry->phar->fp && entry->fp != entry->phar->ufp) {\n\t\tif (!entry->fp_refcount) {\n\t\t\tphp_stream_close(entry->fp);\n\t\t}\n\t\tentry->fp = NULL;\n\t}\n\n\tentry->fp_type = PHAR_FP;\n\n\t/* note new location within tar */\n\tentry->offset = entry->offset_abs = pos;\n\treturn ZEND_HASH_APPLY_KEEP;\n}\n/* }}} */\n\nstatic int phar_tar_writeheaders(zval *zv, void *argument) /* {{{ */\n{\n\treturn phar_tar_writeheaders_int(Z_PTR_P(zv), argument);\n}\n/* }}} */\n\nint phar_tar_setmetadata(zval *metadata, phar_entry_info *entry, char **error) /* {{{ */\n{\n\tphp_serialize_data_t metadata_hash;\n\n\tif (entry->metadata_str.s) {\n\t\tsmart_str_free(&entry->metadata_str);\n\t}\n\n\tentry->metadata_str.s = NULL;\n\tPHP_VAR_SERIALIZE_INIT(metadata_hash);\n\tphp_var_serialize(&entry->metadata_str, metadata, &metadata_hash);\n\tPHP_VAR_SERIALIZE_DESTROY(metadata_hash);\n\tentry->uncompressed_filesize = entry->compressed_filesize = entry->metadata_str.s ? ZSTR_LEN(entry->metadata_str.s) : 0;\n\n\tif (entry->fp && entry->fp_type == PHAR_MOD) {\n\t\tphp_stream_close(entry->fp);\n\t}\n\n\tentry->fp_type = PHAR_MOD;\n\tentry->is_modified = 1;\n\tentry->fp = php_stream_fopen_tmpfile();\n\tentry->offset = entry->offset_abs = 0;\n\tif (entry->fp == NULL) {\n\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\treturn -1;\n\t}\n\tif (ZSTR_LEN(entry->metadata_str.s) != php_stream_write(entry->fp, ZSTR_VAL(entry->metadata_str.s), ZSTR_LEN(entry->metadata_str.s))) {\n\t\tspprintf(error, 0, \"phar tar error: unable to write metadata to magic metadata file \\\"%s\\\"\", entry->filename);\n\t\tzend_hash_str_del(&(entry->phar->manifest), entry->filename, entry->filename_len);\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\n\treturn ZEND_HASH_APPLY_KEEP;\n}\n/* }}} */\n\nstatic int phar_tar_setupmetadata(zval *zv, void *argument) /* {{{ */\n{\n\tint lookfor_len;\n\tstruct _phar_pass_tar_info *i = (struct _phar_pass_tar_info *)argument;\n\tchar *lookfor, **error = i->error;\n\tphar_entry_info *entry = (phar_entry_info *)Z_PTR_P(zv), *metadata, newentry = {0};\n\n\tif (entry->filename_len >= sizeof(\".phar/.metadata\") && !memcmp(entry->filename, \".phar/.metadata\", sizeof(\".phar/.metadata\")-1)) {\n\t\tif (entry->filename_len == sizeof(\".phar/.metadata.bin\")-1 && !memcmp(entry->filename, \".phar/.metadata.bin\", sizeof(\".phar/.metadata.bin\")-1)) {\n\t\t\treturn phar_tar_setmetadata(&entry->phar->metadata, entry, error);\n\t\t}\n\t\t/* search for the file this metadata entry references */\n\t\tif (entry->filename_len >= sizeof(\".phar/.metadata/\") + sizeof(\"/.metadata.bin\") - 1 && !zend_hash_str_exists(&(entry->phar->manifest), entry->filename + sizeof(\".phar/.metadata/\") - 1, entry->filename_len - (sizeof(\"/.metadata.bin\") - 1 + sizeof(\".phar/.metadata/\") - 1))) {\n\t\t\t/* this is orphaned metadata, erase it */\n\t\t\treturn ZEND_HASH_APPLY_REMOVE;\n\t\t}\n\t\t/* we can keep this entry, the file that refers to it exists */\n\t\treturn ZEND_HASH_APPLY_KEEP;\n\t}\n\n\tif (!entry->is_modified) {\n\t\treturn ZEND_HASH_APPLY_KEEP;\n\t}\n\n\t/* now we are dealing with regular files, so look for metadata */\n\tlookfor_len = spprintf(&lookfor, 0, \".phar/.metadata/%s/.metadata.bin\", entry->filename);\n\n\tif (Z_TYPE(entry->metadata) == IS_UNDEF) {\n\t\tzend_hash_str_del(&(entry->phar->manifest), lookfor, lookfor_len);\n\t\tefree(lookfor);\n\t\treturn ZEND_HASH_APPLY_KEEP;\n\t}\n\n\tif (NULL != (metadata = zend_hash_str_find_ptr(&(entry->phar->manifest), lookfor, lookfor_len))) {\n\t\tint ret;\n\t\tret = phar_tar_setmetadata(&entry->metadata, metadata, error);\n\t\tefree(lookfor);\n\t\treturn ret;\n\t}\n\n\tnewentry.filename = lookfor;\n\tnewentry.filename_len = lookfor_len;\n\tnewentry.phar = entry->phar;\n\tnewentry.tar_type = TAR_FILE;\n\tnewentry.is_tar = 1;\n\n\tif (NULL == (metadata = zend_hash_str_add_mem(&(entry->phar->manifest), lookfor, lookfor_len, (void *)&newentry, sizeof(phar_entry_info)))) {\n\t\tefree(lookfor);\n\t\tspprintf(error, 0, \"phar tar error: unable to add magic metadata file to manifest for file \\\"%s\\\"\", entry->filename);\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\n\treturn phar_tar_setmetadata(&entry->metadata, metadata, error);\n}\n/* }}} */\n\nint phar_tar_flush(phar_archive_data *phar, char *user_stub, zend_long len, int defaultstub, char **error) /* {{{ */\n{\n\tphar_entry_info entry = {0};\n\tstatic const char newstub[] = \"<?php // tar-based phar archive stub file\\n__HALT_COMPILER();\";\n\tphp_stream *oldfile, *newfile, *stubfile;\n\tint closeoldfile, free_user_stub, signature_length;\n\tstruct _phar_pass_tar_info pass;\n\tchar *buf, *signature, *tmp, sigbuf[8];\n\tchar halt_stub[] = \"__HALT_COMPILER();\";\n\n\tentry.flags = PHAR_ENT_PERM_DEF_FILE;\n\tentry.timestamp = time(NULL);\n\tentry.is_modified = 1;\n\tentry.is_crc_checked = 1;\n\tentry.is_tar = 1;\n\tentry.tar_type = '0';\n\tentry.phar = phar;\n\tentry.fp_type = PHAR_MOD;\n\tentry.fp = NULL;\n\tentry.filename = NULL;\n\n\tif (phar->is_persistent) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"internal error: attempt to flush cached tar-based phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\t\treturn EOF;\n\t}\n\n\tif (phar->is_data) {\n\t\tgoto nostub;\n\t}\n\n\t/* set alias */\n\tif (!phar->is_temporary_alias && phar->alias_len) {\n\t\tentry.filename = estrndup(\".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1);\n\t\tentry.filename_len = sizeof(\".phar/alias.txt\")-1;\n\t\tentry.fp = php_stream_fopen_tmpfile();\n\t\tif (entry.fp == NULL) {\n\t\t\tefree(entry.filename);\n\t\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (phar->alias_len != (int)php_stream_write(entry.fp, phar->alias, phar->alias_len)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to set alias in tar-based phar \\\"%s\\\"\", phar->fname);\n\t\t\t}\n\t\t\tphp_stream_close(entry.fp);\n\t\t\tefree(entry.filename);\n\t\t\treturn EOF;\n\t\t}\n\n\t\tentry.uncompressed_filesize = phar->alias_len;\n\n\t\tif (NULL == zend_hash_str_update_mem(&phar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info))) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to set alias in tar-based phar \\\"%s\\\"\", phar->fname);\n\t\t\t}\n\t\t\tphp_stream_close(entry.fp);\n\t\t\tefree(entry.filename);\n\t\t\treturn EOF;\n\t\t}\n\t\t/* At this point the entry is saved into the manifest. The manifest destroy\n\t\t\troutine will care about any resources to be freed. */\n\t} else {\n\t\tzend_hash_str_del(&phar->manifest, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1);\n\t}\n\n\t/* set stub */\n\tif (user_stub && !defaultstub) {\n\t\tchar *pos;\n\t\tif (len < 0) {\n\t\t\t/* resource passed in */\n\t\t\tif (!(php_stream_from_zval_no_verify(stubfile, (zval *)user_stub))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to access resource to copy stub to new tar-based phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\tif (len == -1) {\n\t\t\t\tlen = PHP_STREAM_COPY_ALL;\n\t\t\t} else {\n\t\t\t\tlen = -len;\n\t\t\t}\n\t\t\tuser_stub = 0;\n\n\t\t\t// TODO: refactor to avoid reallocation ???\n//???\t\tlen = php_stream_copy_to_mem(stubfile, &user_stub, len, 0)\n\t\t\t{\n\t\t\t\tzend_string *str = php_stream_copy_to_mem(stubfile, len, 0);\n\t\t\t\tif (str) {\n\t\t\t\t\tlen = ZSTR_LEN(str);\n\t\t\t\t\tuser_stub = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));\n\t\t\t\t\tzend_string_release(str);\n\t\t\t\t} else {\n\t\t\t\t\tuser_stub = NULL;\n\t\t\t\t\tlen = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!len || !user_stub) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to read resource to copy stub to new tar-based phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\tfree_user_stub = 1;\n\t\t} else {\n\t\t\tfree_user_stub = 0;\n\t\t}\n\n\t\ttmp = estrndup(user_stub, len);\n\t\tif ((pos = php_stristr(tmp, halt_stub, len, sizeof(halt_stub) - 1)) == NULL) {\n\t\t\tefree(tmp);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"illegal stub for tar-based phar \\\"%s\\\"\", phar->fname);\n\t\t\t}\n\t\t\tif (free_user_stub) {\n\t\t\t\tefree(user_stub);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tpos = user_stub + (pos - tmp);\n\t\tefree(tmp);\n\n\t\tlen = pos - user_stub + 18;\n\t\tentry.fp = php_stream_fopen_tmpfile();\n\t\tif (entry.fp == NULL) {\n\t\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\t\treturn EOF;\n\t\t}\n\t\tentry.uncompressed_filesize = len + 5;\n\n\t\tif ((size_t)len != php_stream_write(entry.fp, user_stub, len)\n\t\t||            5 != php_stream_write(entry.fp, \" ?>\\r\\n\", 5)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to create stub from string in new tar-based phar \\\"%s\\\"\", phar->fname);\n\t\t\t}\n\t\t\tif (free_user_stub) {\n\t\t\t\tefree(user_stub);\n\t\t\t}\n\t\t\tphp_stream_close(entry.fp);\n\t\t\treturn EOF;\n\t\t}\n\n\t\tentry.filename = estrndup(\".phar/stub.php\", sizeof(\".phar/stub.php\")-1);\n\t\tentry.filename_len = sizeof(\".phar/stub.php\")-1;\n\t\tzend_hash_str_update_mem(&phar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info));\n\n\t\tif (free_user_stub) {\n\t\t\tefree(user_stub);\n\t\t}\n\t} else {\n\t\t/* Either this is a brand new phar (add the stub), or the default stub is required (overwrite the stub) */\n\t\tentry.fp = php_stream_fopen_tmpfile();\n\t\tif (entry.fp == NULL) {\n\t\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\t\treturn EOF;\n\t\t}\n\t\tif (sizeof(newstub)-1 != php_stream_write(entry.fp, newstub, sizeof(newstub)-1)) {\n\t\t\tphp_stream_close(entry.fp);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to %s stub in%star-based phar \\\"%s\\\", failed\", user_stub ? \"overwrite\" : \"create\", user_stub ? \" \" : \" new \", phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\tentry.uncompressed_filesize = entry.compressed_filesize = sizeof(newstub) - 1;\n\t\tentry.filename = estrndup(\".phar/stub.php\", sizeof(\".phar/stub.php\")-1);\n\t\tentry.filename_len = sizeof(\".phar/stub.php\")-1;\n\n\t\tif (!defaultstub) {\n\t\t\tif (!zend_hash_str_exists(&phar->manifest, \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\t\t\tif (NULL == zend_hash_str_add_mem(&phar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info))) {\n\t\t\t\t\tphp_stream_close(entry.fp);\n\t\t\t\t\tefree(entry.filename);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"unable to create stub in tar-based phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn EOF;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tphp_stream_close(entry.fp);\n\t\t\t\tefree(entry.filename);\n\t\t\t}\n\t\t} else {\n\t\t\tif (NULL == zend_hash_str_update_mem(&phar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info))) {\n\t\t\t\tphp_stream_close(entry.fp);\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to overwrite stub in tar-based phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t}\n\t}\nnostub:\n\tif (phar->fp && !phar->is_brandnew) {\n\t\toldfile = phar->fp;\n\t\tcloseoldfile = 0;\n\t\tphp_stream_rewind(oldfile);\n\t} else {\n\t\toldfile = php_stream_open_wrapper(phar->fname, \"rb\", 0, NULL);\n\t\tcloseoldfile = oldfile != NULL;\n\t}\n\n\tnewfile = php_stream_fopen_tmpfile();\n\tif (!newfile) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to create temporary file\");\n\t\t}\n\t\tif (closeoldfile) {\n\t\t\tphp_stream_close(oldfile);\n\t\t}\n\t\treturn EOF;\n\t}\n\n\tpass.old = oldfile;\n\tpass.new = newfile;\n\tpass.error = error;\n\tpass.free_fp = 1;\n\tpass.free_ufp = 1;\n\n\tif (Z_TYPE(phar->metadata) != IS_UNDEF) {\n\t\tphar_entry_info *mentry;\n\t\tif (NULL != (mentry = zend_hash_str_find_ptr(&(phar->manifest), \".phar/.metadata.bin\", sizeof(\".phar/.metadata.bin\")-1))) {\n\t\t\tif (ZEND_HASH_APPLY_KEEP != phar_tar_setmetadata(&phar->metadata, mentry, error)) {\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t} else {\n\t\t\tphar_entry_info newentry = {0};\n\n\t\t\tnewentry.filename = estrndup(\".phar/.metadata.bin\", sizeof(\".phar/.metadata.bin\")-1);\n\t\t\tnewentry.filename_len = sizeof(\".phar/.metadata.bin\")-1;\n\t\t\tnewentry.phar = phar;\n\t\t\tnewentry.tar_type = TAR_FILE;\n\t\t\tnewentry.is_tar = 1;\n\n\t\t\tif (NULL == (mentry = zend_hash_str_add_mem(&(phar->manifest), \".phar/.metadata.bin\", sizeof(\".phar/.metadata.bin\")-1, (void *)&newentry, sizeof(phar_entry_info)))) {\n\t\t\t\tspprintf(error, 0, \"phar tar error: unable to add magic metadata file to manifest for phar archive \\\"%s\\\"\", phar->fname);\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\n\t\t\tif (ZEND_HASH_APPLY_KEEP != phar_tar_setmetadata(&phar->metadata, mentry, error)) {\n\t\t\t\tzend_hash_str_del(&(phar->manifest), \".phar/.metadata.bin\", sizeof(\".phar/.metadata.bin\")-1);\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t}\n\t}\n\n\tzend_hash_apply_with_argument(&phar->manifest, phar_tar_setupmetadata, (void *) &pass);\n\n\tif (error && *error) {\n\t\tif (closeoldfile) {\n\t\t\tphp_stream_close(oldfile);\n\t\t}\n\n\t\t/* on error in the hash iterator above, error is set */\n\t\tphp_stream_close(newfile);\n\t\treturn EOF;\n\t}\n\n\tzend_hash_apply_with_argument(&phar->manifest, phar_tar_writeheaders, (void *) &pass);\n\n\t/* add signature for executable tars or tars explicitly set with setSignatureAlgorithm */\n\tif (!phar->is_data || phar->sig_flags) {\n\t\tif (FAILURE == phar_create_signature(phar, newfile, &signature, &signature_length, error)) {\n\t\t\tif (error) {\n\t\t\t\tchar *save = *error;\n\t\t\t\tspprintf(error, 0, \"phar error: unable to write signature to tar-based phar: %s\", save);\n\t\t\t\tefree(save);\n\t\t\t}\n\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\n\t\t\tphp_stream_close(newfile);\n\t\t\treturn EOF;\n\t\t}\n\n\t\tentry.filename = \".phar/signature.bin\";\n\t\tentry.filename_len = sizeof(\".phar/signature.bin\")-1;\n\t\tentry.fp = php_stream_fopen_tmpfile();\n\t\tif (entry.fp == NULL) {\n\t\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\t\treturn EOF;\n\t\t}\n#ifdef WORDS_BIGENDIAN\n# define PHAR_SET_32(var, buffer) \\\n\t*(uint32_t *)(var) = (((((unsigned char*)&(buffer))[3]) << 24) \\\n\t\t| ((((unsigned char*)&(buffer))[2]) << 16) \\\n\t\t| ((((unsigned char*)&(buffer))[1]) << 8) \\\n\t\t| (((unsigned char*)&(buffer))[0]))\n#else\n# define PHAR_SET_32(var, buffer) *(uint32_t *)(var) = (uint32_t) (buffer)\n#endif\n\t\tPHAR_SET_32(sigbuf, phar->sig_flags);\n\t\tPHAR_SET_32(sigbuf + 4, signature_length);\n\n\t\tif (8 != (int)php_stream_write(entry.fp, sigbuf, 8) || signature_length != (int)php_stream_write(entry.fp, signature, signature_length)) {\n\t\t\tefree(signature);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"phar error: unable to write signature to tar-based phar %s\", phar->fname);\n\t\t\t}\n\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\treturn EOF;\n\t\t}\n\n\t\tefree(signature);\n\t\tentry.uncompressed_filesize = entry.compressed_filesize = signature_length + 8;\n\t\t/* throw out return value and write the signature */\n\t\tentry.filename_len = phar_tar_writeheaders_int(&entry, (void *)&pass);\n\n\t\tif (error && *error) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\t/* error is set by writeheaders */\n\t\t\tphp_stream_close(newfile);\n\t\t\treturn EOF;\n\t\t}\n\t} /* signature */\n\n\t/* add final zero blocks */\n\tbuf = (char *) ecalloc(1024, 1);\n\tphp_stream_write(newfile, buf, 1024);\n\tefree(buf);\n\n\tif (closeoldfile) {\n\t\tphp_stream_close(oldfile);\n\t}\n\n\t/* on error in the hash iterator above, error is set */\n\tif (error && *error) {\n\t\tphp_stream_close(newfile);\n\t\treturn EOF;\n\t}\n\n\tif (phar->fp && pass.free_fp) {\n\t\tphp_stream_close(phar->fp);\n\t}\n\n\tif (phar->ufp) {\n\t\tif (pass.free_ufp) {\n\t\t\tphp_stream_close(phar->ufp);\n\t\t}\n\t\tphar->ufp = NULL;\n\t}\n\n\tphar->is_brandnew = 0;\n\tphp_stream_rewind(newfile);\n\n\tif (phar->donotflush) {\n\t\t/* deferred flush */\n\t\tphar->fp = newfile;\n\t} else {\n\t\tphar->fp = php_stream_open_wrapper(phar->fname, \"w+b\", IGNORE_URL|STREAM_MUST_SEEK|REPORT_ERRORS, NULL);\n\t\tif (!phar->fp) {\n\t\t\tphar->fp = newfile;\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to open new phar \\\"%s\\\" for writing\", phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\tif (phar->flags & PHAR_FILE_COMPRESSED_GZ) {\n\t\t\tphp_stream_filter *filter;\n\t\t\t/* to properly compress, we have to tell zlib to add a zlib header */\n\t\t\tzval filterparams;\n\n\t\t\tarray_init(&filterparams);\n/* this is defined in zlib's zconf.h */\n#ifndef MAX_WBITS\n#define MAX_WBITS 15\n#endif\n\t\t\tadd_assoc_long(&filterparams, \"window\", MAX_WBITS + 16);\n\t\t\tfilter = php_stream_filter_create(\"zlib.deflate\", &filterparams, php_stream_is_persistent(phar->fp));\n\t\t\tzval_dtor(&filterparams);\n\n\t\t\tif (!filter) {\n\t\t\t\t/* copy contents uncompressed rather than lose them */\n\t\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"unable to compress all contents of phar \\\"%s\\\" using zlib, PHP versions older than 5.2.6 have a buggy zlib\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\n\t\t\tphp_stream_filter_append(&phar->fp->writefilters, filter);\n\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\tphp_stream_filter_remove(filter, 1);\n\t\t\tphp_stream_close(phar->fp);\n\t\t\t/* use the temp stream as our base */\n\t\t\tphar->fp = newfile;\n\t\t} else if (phar->flags & PHAR_FILE_COMPRESSED_BZ2) {\n\t\t\tphp_stream_filter *filter;\n\n\t\t\tfilter = php_stream_filter_create(\"bzip2.compress\", NULL, php_stream_is_persistent(phar->fp));\n\t\t\tphp_stream_filter_append(&phar->fp->writefilters, filter);\n\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\tphp_stream_filter_remove(filter, 1);\n\t\t\tphp_stream_close(phar->fp);\n\t\t\t/* use the temp stream as our base */\n\t\t\tphar->fp = newfile;\n\t\t} else {\n\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\t/* we could also reopen the file in \"rb\" mode but there is no need for that */\n\t\t\tphp_stream_close(newfile);\n\t\t}\n\t}\n\treturn EOF;\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */\n",
  "is_vul": true,
  "report": "{\"vulnerabilities\": [{\"vul_type\": \"对限制目录的路径名限制不当（路径穿越）\", \"vul_sink_point\": \"entry.filename = pestrndup(hdr->name, i, myphar->is_persistent);\", \"vul_description\": \"在 PHP 5.3.0 到 5.4.41 版本中，ext/phar/phar.c 存在目录遍历漏洞，允许远程攻击者通过精心构造的 phar 文件中的 extract() 函数读取任意文件。\", \"vul_level\": \"高\"}]}"
}